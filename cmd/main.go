package main

import (
	"bytes"
	"fmt"
	"html/template"
	"io/ioutil"
	"os"
	"path/filepath"
	"strings"
)

var templateStr = `// Code generated by tools. DO NOT EDIT.
package zapencoder

import "go.uber.org/zap/zapcore"
import "fmt"
import "strconv"
import "time"

func str(arg interface{}) string {
	switch v := arg.(type) {
	case []byte:
		return string(v)
	case bool:
		if v {
			return "1"
		}
		return "0"
	case *bool:
		if *v {
			return "1"
		}
		return "0"
	case float64:
		return strconv.FormatFloat(v, 'f', -1, 64)
	case *float64:
		return strconv.FormatFloat(*v, 'f', -1, 64)
	case float32:
		return strconv.FormatFloat(float64(v), 'f', -1, 32)
	case *float32:
		return strconv.FormatFloat(float64(*v), 'f', -1, 32)
	case int:
		return strconv.Itoa(v)
	case *int:
		return strconv.Itoa(*v)
	case int8:
		return strconv.FormatInt(int64(v), 10)
	case *int8:
		return strconv.FormatInt(int64(*v), 10)
	case int32:
		return strconv.FormatInt(int64(v), 10)
	case *int32:
		return strconv.FormatInt(int64(*v), 10)
	case int64:
		return strconv.FormatInt(v, 10)
	case *int64:
		return strconv.FormatInt(*v, 10)
	case uint:
		return strconv.FormatUint(uint64(v), 10)
	case *uint:
		return strconv.FormatUint(uint64(*v), 10)
	case uint8:
		return strconv.FormatUint(uint64(v), 10)
	case *uint8:
		return strconv.FormatUint(uint64(*v), 10)
	case uint32:
		return strconv.FormatUint(uint64(v), 10)
	case *uint32:
		return strconv.FormatUint(uint64(*v), 10)
	case uint64:
		return strconv.FormatUint(v, 10)
	case *uint64:
		return strconv.FormatUint(*v, 10)
	case string:
		return v
	case *string:
		return *v
	case time.Time:
		return v.Format(time.RFC3339Nano)
	case *time.Time:
		return (*v).Format(time.RFC3339Nano)
	}
	return fmt.Sprint(arg)
}

func addObject(encoder zapcore.ObjectEncoder, k, v interface{}) (err error) {
	switch vv := v.(type) {
	case zapcore.ArrayMarshaler:
		err = encoder.AddArray(str(k), vv)
	case zapcore.ObjectMarshaler:
		err = encoder.AddObject(str(k), vv)
	case []byte:
		encoder.AddByteString(str(k), vv)
	case bool:
		encoder.AddBool(str(k), vv)
	case *bool:
		encoder.AddBool(str(k), *vv)
	case complex128:
		encoder.AddComplex128(str(k), vv)
	case *complex128:
		encoder.AddComplex128(str(k), *vv)
	case complex64:
		encoder.AddComplex64(str(k), vv)
	case *complex64:
		encoder.AddComplex64(str(k), *vv)
	case time.Duration:
		encoder.AddDuration(str(k), vv)
	case *time.Duration:
		encoder.AddDuration(str(k), *vv)
	case float64:
		encoder.AddFloat64(str(k), vv)
	case *float64:
		encoder.AddFloat64(str(k), *vv)
	case float32:
		encoder.AddFloat32(str(k), vv)
	case *float32:
		encoder.AddFloat32(str(k), *vv)
	case int:
		encoder.AddInt(str(k), vv)
	case *int:
		encoder.AddInt(str(k), *vv)
	case int32:
		encoder.AddInt32(str(k), vv)
	case *int32:
		encoder.AddInt32(str(k), *vv)
	case int64:
		encoder.AddInt64(str(k), vv)
	case *int64:
		encoder.AddInt64(str(k), *vv)
	case int8:
		encoder.AddInt8(str(k), vv)
	case *int8:
		encoder.AddInt8(str(k), *vv)
	case uint:
		encoder.AddUint(str(k), vv)
	case *uint:
		encoder.AddUint(str(k), *vv)
	case uint32:
		encoder.AddUint32(str(k), vv)
	case *uint32:
		encoder.AddUint32(str(k), *vv)
	case uint64:
		encoder.AddUint64(str(k), vv)
	case *uint64:
		encoder.AddUint64(str(k), *vv)
	case uint8:
		encoder.AddUint8(str(k), vv)
	case *uint8:
		encoder.AddUint8(str(k), *vv)
	case string:
		encoder.AddString(str(k), vv)
	case *string:
		encoder.AddString(str(k), *vv)
	case time.Time:
		encoder.AddTime(str(k), vv)
	case *time.Time:
		encoder.AddTime(str(k), *vv)
	case uintptr:
		encoder.AddUintptr(str(k), vv)
	case *uintptr:
		encoder.AddUintptr(str(k), *vv)
	default:
		err = encoder.AddReflected(str(k), vv)
	}
	return err
}

func appendObject(encoder zapcore.ArrayEncoder, v interface{}) (err error) {
	switch vv := v.(type) {
	case zapcore.ArrayMarshaler:
		err = encoder.AppendArray(vv)
	case zapcore.ObjectMarshaler:
		err = encoder.AppendObject(vv)
	case []byte:
		encoder.AppendByteString(vv)
	case bool:
		encoder.AppendBool(vv)
	case *bool:
		encoder.AppendBool(*vv)
	case complex128:
		encoder.AppendComplex128(vv)
	case *complex128:
		encoder.AppendComplex128(*vv)
	case complex64:
		encoder.AppendComplex64(vv)
	case *complex64:
		encoder.AppendComplex64(*vv)
	case time.Duration:
		encoder.AppendDuration(vv)
	case *time.Duration:
		encoder.AppendDuration(*vv)
	case float64:
		encoder.AppendFloat64(vv)
	case *float64:
		encoder.AppendFloat64(*vv)
	case float32:
		encoder.AppendFloat32(vv)
	case *float32:
		encoder.AppendFloat32(*vv)
	case int:
		encoder.AppendInt(vv)
	case *int:
		encoder.AppendInt(*vv)
	case int32:
		encoder.AppendInt32(vv)
	case *int32:
		encoder.AppendInt32(*vv)
	case int64:
		encoder.AppendInt64(vv)
	case *int64:
		encoder.AppendInt64(*vv)
	case int8:
		encoder.AppendInt8(vv)
	case *int8:
		encoder.AppendInt8(*vv)
	case uint:
		encoder.AppendUint(vv)
	case *uint:
		encoder.AppendUint(*vv)
	case uint32:
		encoder.AppendUint32(vv)
	case *uint32:
		encoder.AppendUint32(*vv)
	case uint64:
		encoder.AppendUint64(vv)
	case *uint64:
		encoder.AppendUint64(*vv)
	case uint8:
		encoder.AppendUint8(vv)
	case *uint8:
		encoder.AppendUint8(*vv)
	case string:
		encoder.AppendString(vv)
	case *string:
		encoder.AppendString(*vv)
	case time.Time:
		encoder.AppendTime(vv)
	case *time.Time:
		encoder.AppendTime(*vv)
	case uintptr:
		encoder.AppendUintptr(vv)
	case *uintptr:
		encoder.AppendUintptr(*vv)
	case []interface{}:
		err = encoder.AppendArray(InterfaceSlice{vv})
	default:
		err = encoder.AppendReflected(vv)
	}
	return err
}

{{range $element := .Types }}
	{{- if $element.IsMap }}
		{{- if eq $element.ValueType "interface"}}
type {{ $element.Name }}Map map[{{ $element.KeyType }}]interface{}

func (m {{ $element.Name }}Map) MarshalLogObject(encoder zapcore.ObjectEncoder) error {
	for k, v := range m {
		err := addObject(encoder, k, v)
		if err != nil {
			return err
		}
	}
	return nil
}
		{{- else}}
type {{ $element.Name }}Map map[{{ $element.KeyType }}]{{ $element.ValueType }}
	
func (m {{ $element.Name }}Map) MarshalLogObject(encoder zapcore.ObjectEncoder) error {
	for k, v := range m {
		{{- if $element.HasReturnError }}
		if err := encoder.{{ $element.AddFunc }}; err != nil {
			return err
		}
		{{- else }}
		encoder.{{ $element.AddFunc }}
		{{- end }}
	}
	return nil
}
		{{- end}}
	{{- else }}
		{{- if eq $element.KeyType "interface"}}
type InterfaceSlice []interface{}

func (s InterfaceSlice) MarshalLogArray(encoder zapcore.ArrayEncoder) error {
	for _, v := range s {
		err := appendObject(encoder, v)
		if err != nil {
			return err
		}
	}
	return nil
}
		{{- else}}
type {{ $element.Name }}Slice []{{ $element.KeyType }}

func (s {{ $element.Name }}Slice) MarshalLogArray(encoder zapcore.ArrayEncoder) error {
	for _, v := range s {
		{{- if $element.HasReturnError }}
		if err := encoder.{{ $element.AddFunc }}; err != nil {
			return err
		}
		{{- else }}
		encoder.{{ $element.AddFunc }}
		{{- end }}
	}
	return nil
}
		{{- end }}
	{{- end }}
{{end }}
`

const (
	pointerSuffix = "Pointer"
)

var typeNames = map[string]string{
	"time.Time":  "Time",
	"*time.Time": "Time",
	"[]byte":     "ByteString",
	"*[]byte":    "ByteString",
}

func firstUpper(s string) string {
	s = strings.TrimPrefix(s, "*")
	return strings.ToUpper(s[:1]) + s[1:]
}

func getName(s string) string {
	ss, ok := typeNames[s]
	if !ok {
		ss = firstUpper(s)
	}
	if strings.HasPrefix(s, "*") {
		ss += pointerSuffix
	}
	return ss
}

func getFuncName(s string, isMap bool) string {
	var getPrefixFunc = func(isMap bool) string {
		if isMap {
			return "Add"
		}
		return "Append"
	}
	var getParamFunc = func(s string, isMap bool) string {
		var v string
		if strings.HasPrefix(s, "*") {
			v = "*v"
		} else {
			v = "v"
		}
		if isMap {
			return fmt.Sprintf("(str(k), %s)", v)
		}
		return fmt.Sprintf("(%s)", v)
	}
	name, ok := typeNames[s]
	if !ok {
		name = firstUpper(s)
	}
	return getPrefixFunc(isMap) + name + getParamFunc(s, isMap)
}

type Type struct {
	IsMap          bool
	Name           string
	KeyType        string
	ValueType      string
	HasReturnError bool
	AddFunc        string
}

var types = []string{
	"int", "int8", "int16", "int32", "int64",
	"uint", "uint8", "uint16", "uint32", "uint64",
	"bool", "complex64", "complex128", "float32", "float64", "uintptr", "time.Time", "[]byte", "interface", "string",
}

func getKeys() []string {
	var out []string
	for _, v := range types {
		out = append(out, v)
		if v != "interface" {
			out = append(out, fmt.Sprintf("*%s", v))
		}
	}
	return out
}

func genTypes() []Type {
	var out []Type
	for _, v := range getKeys() {
		out = append(out, Type{IsMap: false, Name: getName(v), KeyType: v, HasReturnError: false, AddFunc: getFuncName(v, false)})
	}
	for _, k := range getKeys() {
		if k == "interface" || k == "[]byte" || k == "*[]byte" {
			continue
		}
		for _, v := range getKeys() {
			out = append(out, Type{IsMap: true, Name: fmt.Sprintf("%s%s", getName(k), getName(v)), KeyType: k, ValueType: v, HasReturnError: false, AddFunc: getFuncName(v, true)})
		}
	}
	return out
}

func main() {
	var fileName = "zapencoder/gen.go"
	t, err := template.New("gen").Parse(templateStr)
	if err != nil {
		panic(err)
	}
	buf := bytes.NewBuffer(nil)
	err = t.Execute(buf, map[string][]Type{"Types": genTypes()})
	if err != nil {
		panic(err)
	}
	bytesUsing := buf.Bytes()
	err = os.MkdirAll(filepath.Dir(fileName), os.ModePerm)
	if err != nil {
		panic(err)
	}
	err = ioutil.WriteFile(fileName, bytesUsing, 0644)
	if err != nil {
		panic(err)
	}
}
